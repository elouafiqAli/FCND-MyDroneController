# Project Write Up #

In this project our objective is to implement components of a Drone Controller, by going through the recommended steps in the course:

- Body-rate controller
- Roll-pitch controller
- Altitude controller
- Lateral controller
- Yaw controller

In this write up we will go step by step for the design decisions, based from first principles till we build up the controller.

The architecture of the controller was derived from Professor Angela P. Schoellig work, from the Udacity course, and from her publications. The controller design is based on the _continuous-time_ system dynamics representation, for a trajectory following application.

![Drone Controller Architecture](/img/angel_schoellig_architecture_control.png)

More on A. P. Schoellig, C. Wiltsche and R. D'Andrea, !["Feed-forward parameter identification for precise periodic quadrocopter motions"](https://www.dynsyslab.org/wp-content/papercite-data/pdf/schoellig-acc12.pdf) 2012 American Control Conference (ACC),

## Deriving Motor Forces and Body Rate - Scenario 2 ##

In order to go explain how we did derive the Motor forces and Body Rates, we would have to go to explain first principles.


### Physical Configuration Layout and Principles

A quadcopter in an "X" configuration has four motors arranged symmetrically around its center of mass but oriented diagonally relative to the body's forward direction. This layout facilitates nuanced control over flight dynamics, including lift (thrust), roll ( $\phi$ ), pitch ( $\theta$ ), and yaw ( $\psi$ ), through differential thrust among the four motors.

* $F_1$ Motor 1 (Front Left)
* $F_2$ Motor 2 (Front Right)
* $F_3$ Motor 3 (Rear Right)
* $F_4$ Motor 4 (Rear Left)


![Drone Propeller Motors Clock Wise and Counter Clockwise](/img/udacity_drone_propellers_CCW_CW.png)

### Equations for Dynamics


1. **Total Thrust $T$**: The collective lift or vertical thrust exerted by the quadcopter against gravity. It's the sum of the thrusts from all four motors:
 $T = F_1 + F_2 + F_3 + F_4 $ 

2. **Roll Moment $\tau_{\phi}$**: Generated by creating a differential in thrust between the left and right sets of motors. In an "X" configuration, this involves all four motors due to their diagonal arrangement:
 $\tau_{\phi} = (F_1 + F_3) - (F_2 + F_4) \times d $ 

3. **Pitch Moment $\tau_{\theta}$**: Similar to roll but involves creating a differential in thrust between the front and back motors:
 $\tau_{\theta} = (F_1 + F_2) - (F_3 + F_4) \times d $ 

4. **Yaw Moment $\tau_{\psi}$**: Arises from the torque difference due to counter-rotating pairs of motors. This differential torque induces rotation about the quadcopter's vertical axis:
 $\tau_{\psi} = (F_1 - F_2 + F_3 - F_4) \times \kappa $ 

Here,  $d$  is the distance from each motor to the center of mass, and  $\kappa$  represents the conversion factor from motor speed to generated torque, taking into account the aerodynamic drag of the propellers.

### Derivation of Control Matrix from Motor Ratios and Physical Parameters

The following matrix directly maps the desired flight dynamics ( $T, \tau_{\phi}, \tau_{\theta}, \tau_{\psi}$ ) to the individual motor thrust commands ( $F_1, F_2, F_3, F_4$ ). For an "X" configuration quadcopter, considering the above equations and simplifying based on symmetric design and equal arm lengths, we can express as:

```math
\begin{bmatrix}
T \\
\tau_{\phi} \cdot d^{-1} \\
\tau_{\theta} \cdot d^{-1} \\
\tau_{\psi} \cdot \kappa^{-1}
\end{bmatrix}
=
\begin{bmatrix}
1 & 1 & 1 & 1 \\
1 & -1 & 1 & -1 \\
1 & 1 & -1 & -1 \\
1 & -1 & -1 & 1
\end{bmatrix}
\begin{bmatrix}
F_1 \\
F_2 \\
F_3 \\
F_4
\end{bmatrix}
```

from which we can derive the forces system

```math
\begin{bmatrix}
F_1 \\
F_2 \\
F_3 \\
F_4
\end{bmatrix}
= \frac{1}{4}
\begin{bmatrix}
1 & \frac{1}{d} & \frac{1}{d} & \frac{1}{\kappa} \\
1 & -\frac{1}{d} & \frac{1}{d} & -\frac{1}{\kappa} \\
1 & \frac{1}{d} & -\frac{1}{d} & -\frac{1}{\kappa} \\
1 & -\frac{1}{d} & -\frac{1}{d} & \frac{1}{\kappa}
\end{bmatrix}
\begin{bmatrix}
T \\
\tau_{\phi} \\
\tau_{\theta} \\
\tau_{\psi}
\end{bmatrix}
```

By solving the system we do optain individual Motor forces:

1. **Front-left Motor $F_1$**:
```math
F_1 = \frac{1}{4} \left( T + \frac{\tau_{\phi}}{d} + \frac{\tau_{\theta}}{d} + \frac{\tau_{\psi}}{\kappa} \right)
```

2. **Front-right Motor $F_2$**:

```math
F_2 = \frac{1}{4} \left( T - \frac{\tau_{\phi}}{d} + \frac{\tau_{\theta}}{d} - \frac{\tau_{\psi}}{\kappa} \right)
```

3. **Rear-left Motor $F_3$**:

```math
F_3 = \frac{1}{4} \left( T + \frac{\tau_{\phi}}{d} - \frac{\tau_{\theta}}{d} - \frac{\tau_{\psi}}{\kappa} \right)
```

4. **Rear-right Motor $F_4$**:
```math
F_4 = \frac{1}{4} \left( T - \frac{\tau_{\phi}}{d} - \frac{\tau_{\theta}}{d} + \frac{\tau_{\psi}}{\kappa} \right)
```

Applying $d = L / \sqrt{2}$ and deriving the ratios to simplify the code we get following command adjustments for each motor.

```cpp
VehicleCommand QuadControl::GenerateMotorCommands(float collThrustCmd, V3F momentCmd)
{   
    float tau_psi_z = momentCmd.z / kappa; // Yaw moment / kappa
    float d = L/sqrtf(2.f);
    float tau_phi_x = momentCmd.x / d; // Roll Moment / d
    float tau_teta_y = momentCmd.y / d; // Pitch Moment /d
    
    float cmd_front_left = (collThrustCmd + tau_phi_x + tau_teta_y - tau_psi_z) / 4.f;
    float cmd_front_right = (collThrustCmd - tau_phi_x + tau_teta_y + tau_psi_z) / 4.f;
    float cmd_rear_left = (collThrustCmd + tau_phi_x - tau_teta_y + tau_psi_z) / 4.f;
    float cmd_rear_right = (collThrustCmd - tau_phi_x - tau_teta_y - tau_psi_z) / 4.f;
    
    // Set motor commands in the class variable
    cmd.desiredThrustsN[0] = cmd_front_left;
    cmd.desiredThrustsN[1] = cmd_front_right;
    cmd.desiredThrustsN[2] = cmd_rear_left;
    cmd.desiredThrustsN[3] = cmd_rear_right;
    return cmd;

}
```

### Matrix Representation and Proportional Control for Body Rates

The proportional controller for body rates translates desired angular velocities into moments ( $\tau$ ) by applying proportional gains ( $k_{PQR}$ ) to the rate errors in roll, pitch, and yaw. This can be represented as:
```math
\tau = \mathbf{I} \cdot \mathbf{k}_{PQR} \cdot (\omega_{cmd} - \omega) 
```
where:
-  $\tau$  are the moments needed for correcting angular velocities to their desired values.
-  $\mathbf{I}$  is the inertia matrix, encapsulating the quadcopter's moments of inertia.
-  $\mathbf{k}_{PQR}$  is a diagonal matrix containing the proportional gains for roll, pitch, and yaw controls.
-  $\omega_{cmd}$  and  $\omega$  represent the desired and current angular velocities, respectively.

This formulation ensures that the controller accounts for the drone's physical characteristics, including its moments of inertia, when calculating the commanded moments to achieve desired body rates, thereby stabilizing the quadcopter's orientation and trajectory effectively.

```cpp
V3F QuadControl::BodyRateControl(V3F pqrCmd, V3F pqr)
{

  V3F momentCmd;

  V3F Insta;
  Insta.x = Ixx;
  Insta.y = Iyy;
  Insta.z = Izz;
    
  V3F rateError = pqrCmd - pqr;
    
  momentCmd = Insta* kpPQR * rateError;
  return momentCmd;
}
```

## Deriving Roll and Pitch Control rates - Scenario 2 (continued)

First, we need to understand the desired acceleration in the body frame. The accelerations $\ddot{x}$ and $\ddot{y}$ in the body frame are proportional to the tilt angles $b^x$ and $b^y$ because tilting the drone creates a component of thrust in the respective body frame direction.

The proportional relationship is given by:

```math
\begin{align*}
\ddot{x} = c \cdot b^x \\
\ddot{y} = c \cdot b^y
\end{align*}
```

where:
- $c$ is the total upward thrust generated by the drone's motors divided by the mass of the drone.
- $b^x$ and $b^y$ are the tilt angles in the body frame about the x and y axes, respectively.

Given the desired accelerations $\ddot{x}_c$ and $\ddot{y}_c$ in the body frame, we can solve for the desired tilt angles $b^x_c$ and $b^y_c$:

```math
\begin{align*}
b^x_c = \frac{\ddot{x}_c}{c} \\
b^y_c = \frac{\ddot{y}_c}{c}
\end{align*}
```

The total collective thrust command ($u_1 $) is converted into acceleration by dividing by the mass of the drone:

```math
c = \frac{u_1}{m}
```

The desired tilt angles need to be constrained to ensure they are within the physical limits of the drone's ability to tilt without losing control or altitude. This is done using a constraint function that limits the angles to a maximum tilt angle $( \text{maxTiltAngle} )$:

```math
\begin{align*}
b^x_c = \text{CONSTRAIN}\left(\frac{\ddot{x}_c}{c}, -\text{maxTiltAngle}, \text{maxTiltAngle}\right) \\
b^y_c = \text{CONSTRAIN}\left(\frac{\ddot{y}_c}{c}, -\text{maxTiltAngle}, \text{maxTiltAngle}\right)
\end{align*}
```

In the code, the collective thrust command is negative due to the NED (North, East, Down) coordinate system used:

```cpp
float c = -collThrustCmd / mass;
float b_x_cmd = CONSTRAIN(accelCmd.x / c, -maxTiltAngle, maxTiltAngle);
float b_y_cmd = CONSTRAIN(accelCmd.y / c, -maxTiltAngle, maxTiltAngle);
```

### Proportional Control

A proportional controller adjusts the roll and pitch rates based on the error between the desired and actual tilt angles.

```math
\begin{align*}
\dot{b}^x_c &= k_p \cdot (b^x_c - b^x_a) \\
\dot{b}^y_c &= k_p \cdot (b^y_c - b^y_a)
\end{align*}
```

### Error Calculation

The error for the roll and pitch angles is calculated by subtracting the actual angle obtained from the rotation matrix  $R$ from the desired angle.

```math
\begin{align*}
b_{x_{\text{error}}} &= b^x_c - R_{13} \\
b_{y_{\text{error}}} &= b^y_c - R_{23}
\end{align*}
```

### Signal Generation

The error is then used to generate the control signals, which are the desired body rates for roll $p_c$ and pitch $q_c$

```math
\begin{pmatrix} p_c \\ q_c \end{pmatrix} = \frac{1}{R_{33}} \begin{pmatrix} R_{21} & -R_{11} \\ R_{22} & -R_{12} \end{pmatrix} \times \begin{pmatrix} \dot{b}^x_c \\ \dot{b}^y_c \end{pmatrix}
```

which completes our calculations that that take place in the ```QuadControl::RollPitchControl``` function.

```cpp
V3F QuadControl::RollPitchControl(V3F accelCmd, Quaternion<float> attitude, float collThrustCmd)
{
 V3F pqrCmd;
 Mat3x3F R = attitude.RotationMatrix_IwrtB();
  if (collThrustCmd > 0) {
      float c = -collThrustCmd / mass;
      float b_x_c_target = CONSTRAIN(accelCmd.x / c, -maxTiltAngle, maxTiltAngle);
      float b_y_c_target = CONSTRAIN(accelCmd.y / c, -maxTiltAngle, maxTiltAngle);
      float b_x_error = b_x_c_target - R(0, 2);
      float b_y_error = b_y_c_target - R(1, 2);
      p_cmd = (R(1, 0) * kpBank * b_x_error - R(0, 0) * kpBank * b_y_error) / R(2, 2);
      q_cmd = (R(1, 1) * kpBank * b_x_error - R(0, 1) * kpBank * b_y_error) / R(2, 2);
      pqrCmd.x = p_cmd;
      pqrCmd.y = q_cmd;
  } else {
      pqrCmd.x = 0.0;
      pqrCmd.y = 0.0;
  }
  return pqrCmd;
}
```

The results gives us the following simulation

![Drone Controller Architecture](img/scenario_2_ali_elouafiq.gif)